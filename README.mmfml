This is my amazingâ„¢ standard library.

See the header files for documentation.

= Notes =

1. all functions are namespaced, such as `hashmap_new()`, `string_new()`, `llist_append()` etc...
2.
    `*_new2()` allocates the struct itself on the heap while
    `*_new()` asks for a pointer to a caller-defined value which can be
    stack or heap allocated
    a.
        `*_new2()` must be deleted with `*_del2()`
        and `*_new()` must be deleted with `*_del()`

3. functions should generally work the same no matter what (dont break userspace)
4. struct properties may change, break, etc... do not rely on them

= The Iterable Protocol =

`iter.h` contains a way to implement an iterable object to be used with the foreach macro.

The protocol is very simple.

For example, to implement the iterable protocol for `array` would be as such:

>c
void array_iter(array*, struct iterable_t*);

void array_next(array*);
<

And that's it! The array is responsible for keeping track of all state.

`array_iter` is caled when the user calls the `iter` macro, such as:
>c
array* arr = array_new2(0, 1);
struct iterable_t it = iter(arr, array);
<

`array_next` is called each time `next(it)` is called

In practice this is all handled by the `foreach` macro which can be used as such

>c
array* arr = array_new2(0, 1);
int x = 0;
array_append(arr, &x);
foreach(int*, arr, array, {
    printf("My very cool integer: %d\n", *cur);
});
<

`cur` and `it` are magical vars that are created within the foreach macro scope.
`cur` contains the current item, while `it` contains the iterator itself.
